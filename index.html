<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>밤하늘에 수놓기</title>
  <style>
    :root{
      --piece-min: 14;
      --piece-max: 28;
    }
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; }

    @font-face {
      font-family: 'PyeongchangPeace';
      src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2206-02@1.0/PyeongChangPeace-Light.woff2') format('woff2');
      font-weight: 300;
      font-display: swap;
    }

    .lyrics {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      z-index: 20; width: 90vw; max-width: 1100px; text-align: center;
      font-family: 'PyeongchangPeace', system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      font-weight: 300;
      font-size: clamp(24px, 6vw, 72px);
      line-height: 1.25;
      color: #ffffff; letter-spacing: 0.02em;
      text-shadow: 0 0 10px rgba(255,255,255,.35), 0 0 30px rgba(90,130,255,.3);
      pointer-events: none; user-select: none;
      opacity: 1; transition: opacity 0.8s ease;
      padding: 0 .25em;
    }
    .lyrics.fade { opacity: 0; }

    .piece{
      position: fixed; left: 0; top: 0; z-index: 5;
      width: var(--size); height: var(--size);
      background-repeat: no-repeat;
      background-position: center;
      background-size: contain;
      transform: translate(-50%, -50%) rotate(0deg);
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.45));
      pointer-events: none;
      will-change: transform;
    }

    body{
      cursor: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 48 48">\
  <path fill="%23ffd54f" stroke="%23000" stroke-width="2" d="M24 3l5.9 12 13.1 1.9-9.5 9.2 2.2 12.9L24 32.8 12.3 39l2.2-12.9-9.5-9.2L18.1 15 24 3z"/>\
</svg>') 6 6, auto;
    }
  </style>
</head>
<body>
  <canvas id="sky"></canvas>
  <div id="lyrics" class="lyrics">반짝반짝 작은별</div>
  <audio id="bgm" src=""></audio>

  <script>
  (function () {
    const audio = document.getElementById('bgm');
    audio.src = encodeURI('반짝반짝.mp3');
    audio.loop = true;
    audio.preload = 'auto';
    audio.volume = 0.8;
    let audioStarted = false;
    function startAudioOnce() {
      if (audioStarted) return;
      audio.play().then(() => { audioStarted = true; }).catch(() => { audioStarted = false; });
    }
    window.addEventListener('click', startAudioOnce, { once: true });

    const canvas = document.getElementById('sky');
    const ctx = canvas.getContext('2d', { alpha: false });
    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();
    function paintBackground() {
      const g = ctx.createLinearGradient(0, 0, 0, innerHeight);
      g.addColorStop(0,   '#020512');
      g.addColorStop(0.5, '#070b22');
      g.addColorStop(1,   '#0a1030');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, innerWidth, innerHeight);
    }
    const STAR_COUNT = Math.min(350, Math.floor((innerWidth * innerHeight) / 4000));
    const stars = [];
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({ x: Math.random() * innerWidth, y: Math.random() * innerHeight, r: Math.random() * 1.5 + 0.2, baseA: 0.4 + Math.random() * 0.6, twinkleSpeed: 0.5 + Math.random() * 2.0, phase: Math.random() * Math.PI * 2 });
    }
    const meteors = [];
    const rainbow = [0, 30, 60, 120, 210, 260, 300];
    function spawnMeteor(x, y, speed = 8 + Math.random() * 6, angle = Math.PI * (0.15 + Math.random() * 0.2)) {
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const hue = rainbow[Math.floor(Math.random() * rainbow.length)];
      meteors.push({ x, y, vx, vy, len: 80 + Math.random() * 120, life: 0, ttl: 60 + Math.random() * 40, thickness: 1.5 + Math.random() * 1.5, hue });
    }
    window.addEventListener('click', (e) => { spawnMeteor(e.clientX, e.clientY); });
    setInterval(() => {
      const startX = Math.random() * innerWidth * 0.8 + innerWidth * 0.1;
      const startY = -50;
      spawnMeteor(startX, startY, undefined, Math.PI * (0.25 + Math.random() * 0.15));
    }, 3000 + Math.random() * 3000);
    function drawStars(time) {
      for (const s of stars) {
        const a = s.baseA * (0.6 + 0.4 * Math.abs(Math.sin(time * 0.001 * s.twinkleSpeed + s.phase)));
        ctx.globalAlpha = a;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    function drawMeteors() {
      for (let i = meteors.length - 1; i >= 0; i--) {
        const m = meteors[i];
        m.life++;
        m.x += m.vx;
        m.y += m.vy;
        const tailX = m.x - m.vx * (m.len / Math.hypot(m.vx, m.vy));
        const tailY = m.y - m.vy * (m.len / Math.hypot(m.vx, m.vy));
        const grad = ctx.createLinearGradient(m.x, m.y, tailX, tailY);
        grad.addColorStop(0,   `hsla(${m.hue},100%,80%,1)`);
        grad.addColorStop(0.5, `hsla(${m.hue},100%,60%,0.6)`);
        grad.addColorStop(1,   `hsla(${m.hue},100%,40%,0)`);
        ctx.lineWidth = m.thickness;
        ctx.strokeStyle = grad;
        ctx.beginPath();
        ctx.moveTo(m.x, m.y);
        ctx.lineTo(tailX, tailY);
        ctx.stroke();
        ctx.beginPath();
        ctx.fillStyle = `hsla(${m.hue},100%,90%,0.9)`;
        ctx.arc(m.x, m.y, m.thickness + 0.5, 0, Math.PI * 2);
        ctx.fill();
        if (m.life > m.ttl || m.x < -200 || m.x > innerWidth + 200 || m.y < -200 || m.y > innerHeight + 200) {
          meteors.splice(i, 1);
        }
      }
    }
    function tick(time) {
      paintBackground();
      drawStars(time);
      drawMeteors();
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    const rand = (a, b) => a + Math.random()*(b-a);
    const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
    function starSVG(fillHex="#ffd54f", strokeHex="#000000"){
      const f = fillHex.replace('#','%23');
      const s = strokeHex.replace('#','%23');
      return `url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 48 48"><path fill="${f}" stroke="${s}" stroke-width="2" d="M24 3l5.9 12 13.1 1.9-9.5 9.2 2.2 12.9L24 32.8 12.3 39l2.2-12.9-9.5-9.2L18.1 15 24 3z"/></svg>')`;
    }
    function hslToHex(h, s, l){
      s/=100; l/=100;
      const k=n=>(n+ h/30)%12;
      const a=s*Math.min(l,1-l);
      const f=n=>l - a*Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1)));
      const toHex=x=>Math.round(x*255).toString(16).padStart(2,'0');
      return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
    }
    const RES=3;
    let COLS=Math.ceil(window.innerWidth/RES);
    let heightField=new Array(COLS).fill(0);
    let reserveField=new Array(COLS).fill(0);
    const FLOOR_GAP=8, GUTTER=2;
    let SIGMA=12;
    let RADIUS=Math.ceil(SIGMA*2/RES);
    let KERNEL=makeKernel(SIGMA);
    function makeKernel(sigma){
      const k=[]; let sum=0;
      RADIUS=Math.ceil(sigma*2/RES);
      for(let j=-RADIUS;j<=RADIUS;j++){
        const x=j*RES, w=Math.exp(-(x*x)/(2*sigma*sigma));
        k.push(w); sum+=w;
      }
      return k.map(v=>v/sum);
    }
    const xToIndex=x=>clamp(Math.round(x/RES),0,COLS-1);
    function baseAt(x){
      const ci=xToIndex(x); let base=0;
      for(let j=-RADIUS;j<=RADIUS;j++){
        const i=clamp(ci+j,0,COLS-1);
        base=Math.max(base, heightField[i]+reserveField[i]);
      }
      return base;
    }
    function addSmooth(field,x,amount){
      const ci=xToIndex(x);
      for(let j=-RADIUS;j<=RADIUS;j++){
        const i=clamp(ci+j,0,COLS-1);
        field[i]+=amount*KERNEL[j+RADIUS];
      }
    }
    const pieces=[];
    const flyers=[];
    const PIECE_LIMIT=400;
    function spawnPiece(clientX, clientY){
      const size = Math.round(rand(getCSSpx('--piece-min',14), getCSSpx('--piece-max',28)));
      const hue  = Math.floor(rand(0,360));
      const fill = hslToHex(hue, 85, 60);
      const stroke = "#000000";
      const el = document.createElement('div');
      el.className = 'piece';
      el.style.setProperty('--size', size+'px');
      el.style.backgroundImage = starSVG(fill, stroke);
      const ox=(Math.random()*16-8)|0, oy=(Math.random()*16-8)|0, toolbarH=64;
      const x0=clamp(clientX+ox,8,window.innerWidth-8);
      const y0=Math.max(clientY+oy,toolbarH);
      el.style.left = x0+'px';
      el.style.top  = y0+'px';
      document.body.appendChild(el);
      pieces.push(el);
      if (pieces.length > PIECE_LIMIT){
        const old = pieces.shift();
        if (old && old.isConnected) old.remove();
      }
      const h = size;
      const base=baseAt(x0);
      const targetBottom=base+FLOOR_GAP;
      const targetY=window.innerHeight - h - targetBottom;
      const rise = rand(30, 80);
      const g    = rand(0.35, 0.55);
      let  vy    = -rand(1.8, 2.6);
      const maxVy= 9;
      const rotMax = rand(60, 120);
      let rot = 0;
      const addAmt=h+GUTTER;
      addSmooth(reserveField, x0, addAmt);
      flyers.push({el, x:x0, y:y0, targetY, vy, g, maxVy, upLeft:rise, rot, rotMax, addAmt, x0, targetBottom, h});
      if (!rafId) rafId = requestAnimationFrame(stepFly);
    }
    let rafId=null;
    function stepFly(){
      for (let i=flyers.length-1; i>=0; i--){
        const p = flyers[i];
        if (p.upLeft > 0){
          const dy = Math.min(p.upLeft, 2.5);
          p.y -= dy;
          p.upLeft -= dy;
        } else {
          p.vy = Math.min(p.vy + p.g, p.maxVy);
          p.y += p.vy;
        }
        if (p.rot < p.rotMax){
          p.rot = Math.min(p.rotMax, p.rot + 2);
        }
        p.el.style.transform = `translate(-50%, -50%) rotate(${p.rot}deg)`;
        p.el.style.top = p.y + 'px';
        if (p.y >= p.targetY){
          p.el.style.transform = 'none';
          p.el.style.top = '';
          p.el.style.left = p.x + 'px';
          p.el.style.bottom = p.targetBottom + 'px';
          p.el.style.position = 'fixed';
          addSmooth(reserveField, p.x, -p.addAmt);
          addSmooth(heightField,  p.x,  p.addAmt);
          flyers.splice(i,1);
        }
      }
      if (flyers.length) rafId = requestAnimationFrame(stepFly);
      else rafId = null;
    }
    function getCSSpx(varName, fallback){
      const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      if(!v) return fallback;
      const n = parseFloat(v);
      return Number.isFinite(n)? n : fallback;
    }
    let throttle=0;
    window.addEventListener('mousemove',(e)=>{
      if ((++throttle)%2) return;
      const n = (Math.random() < 0.25) ? 2 : 1;
      for (let i=0;i<n;i++) spawnPiece(e.clientX, e.clientY);
    });
    window.addEventListener('resize', ()=>{
      COLS=Math.ceil(window.innerWidth/RES);
      heightField=new Array(COLS).fill(0);
      reserveField=new Array(COLS).fill(0);
      KERNEL=makeKernel(SIGMA);
      clearPieces();
    });
    window.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase() === 'r') clearPieces();
    });
    function clearPieces(){
      pieces.splice(0).forEach(el=>el.remove());
      flyers.splice(0);
      COLS=Math.ceil(window.innerWidth/RES);
      heightField=new Array(COLS).fill(0);
      reserveField=new Array(COLS).fill(0);
      if (rafId){ cancelAnimationFrame(rafId); rafId=null; }
    }

    const LINES = ["반짝반짝 작은별","아름답게 비치네","동쪽하늘 에서도","서쪽하늘 에서도","반짝반짝 작은별","아름답게 비치네"];
    const lyricEl = document.getElementById('lyrics');
    let li = 0;
    const DURATION = 4500;
    function nextLine(){
      lyricEl.classList.add('fade');
      setTimeout(()=>{
        li = (li + 1) % LINES.length;
        lyricEl.textContent = LINES[li];
        lyricEl.classList.remove('fade');
      }, DURATION/2);
    }
    function scheduleNext(){
      nextLine();
      timer = setTimeout(scheduleNext, DURATION);
    }
    lyricEl.textContent = LINES[0];
    let timer = setTimeout(scheduleNext, DURATION);
  })();
  </script>
</body>
</html>
